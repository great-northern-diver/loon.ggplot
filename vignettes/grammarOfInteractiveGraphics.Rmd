---
title: "A grammar of interactive graphics"
author: "R. W. Oldford and Zehao Xu"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
geometry: margin=.75in
urlcolor: blue
graphics: yes
vignette: >
  %\VignetteIndexEntry{Pipes}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  
---


```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE,
                      message = FALSE,
                      fig.align = "center", 
                      fig.width = 6, 
                      fig.height = 5,
                      out.width = "60%", 
                      collapse = TRUE,
                      comment = "#>",
                      tidy.opts = list(width.cutoff = 65),
                      tidy = FALSE)
library(knitr)
set.seed(12314159)
imageDirectory <- "./l_ggplot"
dataDirectory <- "./l_ggplot"

library(gridExtra, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(dplyr, quietly = TRUE)
library(magrittr, quietly = TRUE)
library(loon, quietly = TRUE)
library(loon.ggplot, quietly = TRUE)
```

Just as `ggplot2` provides a layered implementation of a *grammar of graphics*, `loon.ggplot` provides a layered implementation of a **grammar of interactive graphics**.

With `loon.ggplot`, data analysts can easily switch between the elegant and beautiful static graphics of `ggplot2` and the powerful direct manipulation interactive graphics of `loon`, **using each where it is most natural**.

## `airquality` as a working example

Consider the `airquality` dataset:
```{r}
data("airquality")
summary(airquality)
```
It has missing data (in `Ozone` and `Solar.R`) and the variable `Month` can be tidied up and turned into a factor as
```{r}
airquality$Month <- factor(month.abb[airquality$Month], levels = month.abb)
```

With its mix of continuous and categorical variables (and some with missing data) this transformed data will be used to illustrate the interactive grammar of `loon.ggplot`.

## `l_ggplot()`

An interactive grammar of graphics begins by simply replacing `ggplot()`, wherever it appears in the layered grammar, by `l_ggplot()`.  Use the same arguments (e.g., `data`, `mapping`, etc.)  and the same grammar to construct an interactive plot.

Following the `ggplot2` grammar, but with `l_ggplot()` in place of `ggplot()`,  a scatterplot of `Ozone` versus `Wind` is simply constructed:
```{r, eval = FALSE}
l_ggplot(airquality, 
         mapping = aes(x = Wind, y = Ozone)) +
  ggtitle("Air quality in New York (1973)") +
  geom_point() +
  geom_smooth()
```
The resulting interactive `loon` plot appears in a new window and a separate window containing the `loon` inspector also appears.  Together, these two windows allow changes to be made to the plot via direct mouse interaction.

Had `ggplot()` been used in place of `l_ggplot()` the corresponding `ggplot` would have been rendered on the "current device" when printed.  The two plots are shown side by side below (the `loon` plot at left is a static version rendered via `grid` graphics so will differ slightly from how it appears on screen; especially in terms of font and point sizes):
```{r, echo = FALSE, fig.width = 10, out.width = "80%"}
lgp <- l_ggplot(airquality, 
                mapping = aes(x = Wind, y = Ozone)) +
  ggtitle("Air quality in New York (1973)") +
  geom_point() +
  geom_smooth()
lp <- loon.ggplot(lgp)
grid.arrange(plot(lp, draw = FALSE), lgp, nrow = 1)
```
The two plots present the same information in slightly different form with different choices on title placement, white space padding and so on.

The most important difference with respect to the data is that the error bars for the smooth appear as curves in the `loon` plot and as a transparent grey region in the `ggplot`.  The main reason for this default choice is that `tcl` (on which `loon` is based) does not (yet) support alpha transparency. Note, however, that a similar grey region exists as a **hidden layer**  the `loon` plot; this can be **revealed interactively** via the `loon` inspector.

The `loon` plot is designed for direct interaction; the `ggplot` is designed for elegant print layout.  Both can be constructed via the grammar.

### loon-ggplot duality

The grammar of interactive graphics is effected with `l_ggplot()` by recognizing the complementary strengths of the static `ggplot` and of the interactive `loon` plot.  
Each operates in a separate domain:

- with `ggplot2`, a plot is "changed" by adding to the `+` pipeline and rendering the result into a *new* plot
- with `loon`, a plot can be changed through direct mouse interaction **or** programmatically via the rich set of functions provided by `loon`

The two are combined in `l_ggplot()` allowing for either approach to be used at any time.

To see this, suppose we again construct a scatterplot using `l_ggplot()` but now without a smooth and assigning the result to a variable `lgp`:
```{r}
lgp <- l_ggplot(airquality, mapping = aes(x = Wind, y = Ozone)) +
  ggtitle("Air quality in New York (1973)") +
  geom_point() 
```
No plot of any kind will yet appear; `lgp` is a data structure of class:
```{r}
class(lgp)
```
It is **simultaneously** a `ggplot`  and a `loon` plot (`l_ggplot`).  As such it contains the information needed to construct either plot.  

To render the static `ggplot`, the `plot()` function is called on `lgp`:
```{r}
plot(lgp)
```
This is because when constructed with `l_ggplot()` the  interactive `loon` plot is realized by *printing* `lgp`:
```{r}
lgp
```

Note the printed result is a character vector with class attribute values `"l_plot"` and `"loon"` -- these indicate that a `loon` plot was produced.

In general, the string value will be `".lX.ggplot"`  where `X` is the numerical index (beginning at `0`)  of this `l_ggplot` of all interactive produced so far.  The number `X` appearing in the vignette depends on the number of such interactive plots were produced to this point in constructing the vignette.
Whatever value `X` takes, it will be printed anew each time the `l_ggplot` is "printed"   **and will appear in the title bar of the interactive window**.

This string can be used to assign the `loon` plot in the interactive window to a variable in `R`, say `lp`, as
```{r, eval = FALSE}
lp <- l_getFromPath(".lX.ggplot")   # <<<--- replace X by the appropriate number
```
Alternatively, rather than "print" `lgp` to get an interactive plot, it could have been
created and assigned to an `R` variable `lp` using `loon.ggplot()`
```{r, eval = TRUE}
lp <- loon.ggplot(lgp)
```
which works even if `lgp` had been created with `ggplot()` instead of `l_ggplot()`.

Once captured on a variable, the `loon` plot `lp` can be queried/changed programmatically (as well as interactively).  For example,
```{r}
# Changing glyph aesthetics
lp["color"] <- "firebrick"
lp["glyph"] <- "ctriangle"
lp["size"] <- 10

# Changing the scaling
lp["zoomX"] <- 1.2
lp["zoomY"] <- 1.2

# Change the origin
lp["panX"] <- 7
lp["panY"] <- 0

# All of the above could be done more simply through direct 
# interaction on the plot and/or with the inspector
```


```

Now, the interactive plot `lp` has changed state 
```{r}
plot(lp)
```
but `lgp` (the original structure produced by `l_ggplot()`) has not.
```{r}
plot(lgp)
```

**This is an important distinction**.  The structure `lgp`, like any `ggplot`, contains the information necessary **to construct** a plot.  

- When it is **printed**, with `print()` or in the console, the instructions produce an **interactive** `loon` plot, and
- when it is **plotted**, with `plot()`,  the instructions produce a **static** `ggplot`.




```{r, eval = FALSE}
# And some fancy layer manipulation
l_layer_raise(lp, "model")
for (layerID in l_layer_ids(lp)){ 
  if(l_layer_getLabel(lp, layerID) == "se polygon") {
    l_layer_show(lp, layerID)}
}

```{r, eval = FALSE}
# And some fancy layer manipulation
l_layer_raise(lp, "model")
for (layerID in l_layer_ids(lp)){ 
  if(l_layer_getLabel(lp, layerID) == "se polygon") {
    l_layer_show(lp, layerID)}
}
# All of the above could be done more simply 
# through direct interaction on the plot and 
# on the inspector
```


```


```{r}
colors <- lp["color"]
selected <-  colors == tail(colors, 1)
lp["glyph"][selected] <- "ctriangle"
lp["color"][selected] <- "cornsilk"
lp["size"][selected] <- 10
lp["selected"] <- selected
l_scaleto_selected(lp)
lp["selected"] <- FALSE
plot(lp)
loon.ggplot(lp)
```
The `lggplot` also appears **only when printed**, but now


The `magrittr` package provides several different types of pipes which can be a handy way to organize computation, especially when the computation involves processing data for input to another procedure, in this case `ggplot()`:
```{r pipes, message = FALSE, warning = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
library(dplyr)  # load this to also have dplyr functionality
library(magrittr)
library(loon.ggplot)
p1_piped <- mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  l_ggplot(aes(x = weight, y = lp100km)) +
  geom_point() +
  ylab("Litres per 100 kilometres") +
  ggtitle("Gas usage")
p1_piped
```

Here the "pipe"  `%>%` takes the output of its left hand side and pushes it into the first argument of its right hand side.  Arbitrary many pipes may be gathered together.  
This connects nicely with `ggplot2`'s addition `+` operator (`+` itself is sometimes a pipe, sometimes a layer in `ggplot` construction) to create the `ggplot` from the data and assign it to `p1_piped`.

Two things to note here are.
First, the result of the data manipulation is assigned at the beginning using the `<-` assignment function which seems to run counter to the data flow indicated by the pipes.  A more consistent flow would be to have instead written
```{r consistent_pipe_flow}
mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  ggplot(aes(x = weight, y = lp100km)) +
  geom_point() +
  ylab("Litres per 100 kilometres") +
  ggtitle("Gas usage")  ->   # Note assignment occurs here
  p1_piped
```

Now the assignment operator `->` is used at the end, matching the data flow of the pipes.

Second, in either case the `ggplot` is **not** itself displayed (or rendered) until it is printed.

```{r p1_piped, message = FALSE, warning = FALSE, fig.width = 4, fig.height = 4, fig.align = "center", out.width = "50%"}
p1_piped
```

Once built, as happens when the plot has been displayed as above,  an interactive loon plot can be had as always, simply by calling `ggplot2loon()` on the built `ggplot`:
```{r loon_p1_piped, message = FALSE, warning = FALSE, eval = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
library(loon.ggplot)
ggplot2loon(p1_piped, linkingGroup = "Motor Trend 1974")
```
Again, the additional specification here of the `linkingGroup` will cause display attributes to be pulled from the plots in that linking group.

### Using `gg_pipe(data, ggplotObj)`

Note that before a `ggplot` can be displayed, a number of steps are performed so as to prepare the plot object for rendering (e.g. see `ggplot2::ggplot_build`).
Unfortunately, this delay in completing the preparation of the `ggplot` can make it difficult to attach further operations in the `%>%` pipeline after the `ggplot` itself -- apart of course from further `ggplot2` additions via the `+` operator.
For example, one cannot simply add `%>% ggplot2loon()` at the end of the pipeline used to construct the `ggplot`.  That is,
```{r fail_pipeline, eval = FALSE}
mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  ggplot(aes(x = weight, y = lp100km)) +
  geom_point() +
  ylab("Litres per 100 kilometres") +
  ggtitle("Gas usage") %>% 
  ggplot2loon()
```
would produce neither a `ggplot` or an interactive `loon` plot.

To get around this problem, in `loon.ggplot` the function `gg_pipe()` is provided to encapsulate the `ggplot` construction in any pipeline and force the `ggplot` to be built (though not rendered in a display).  The output of this function can then be passed on to `ggplot2loon()`. 

For example,
```{r gg_pipe, message = FALSE, warning = FALSE, eval = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  # encapsulate the ggplot construction with gg_pipe()
  gg_pipe(ggplot(aes(x = weight, y = lp100km)) +
            geom_point() +
            ylab("Litres per 100 kilometres") +
            ggtitle("Gas usage")
          )  %>% 
  # and pass the built plot on
  ggplot2loon(linkingGroup = "Motor Trend 1974")
```
constructs the interactive plot which could have been assigned to a variable as was done with the original `ggplot` construction.

From here, the pipeline can be grown as before, recognizing of course that the output of `ggplot2loon()` is a `loon` plot of some sort.
This means that functions that operate on `loon` plots (as their first argument can be used.  As with any piping operation, attention must be given to the first argument of the functions in the pipeline as well as to what the input and outputs are of any function.

For example, 

```{r magrittr_pipe, message = FALSE, warning = FALSE, eval = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  # encapsulate the ggplot construction with gg_pipe()
  gg_pipe(ggplot(aes(x = weight, y = lp100km)) +
            geom_point() +
            ylab("Litres per 100 kilometres") +
            ggtitle("Gas usage") )  %>% 
  # and pass the built plot on
  ggplot2loon(linkingGroup = "Motor Trend 1974") %>%  # pipe the loon plot on
  l_cget('color')  # Gets and returns the vector of point colours
```

In the `magrittr` package (the source of the pipeline operation) there are a variety of pipeline operators which might also be useful -- not just `%>%`.

### Using `l_ggplot()`

Additionally, using function `l_ggplot`, can also create a `loon` plot with `ggplot` pipe model.

The display of `ggplot` object relies on the default `print()` function in `R`. Function `l_ggplot`, inserts a new class `lggplot` into the original `ggplot` object. At the printing time, [S3 method](http://adv-r.had.co.nz/S3.html) `print.lggplot()` will be executed to transform a `ggplot` plot to a `loon` plot.
```{r lggplot_pipe, message = FALSE, eval = FALSE}
obj <- mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  # replace `ggplot` to `lggplot`
  l_ggplot(aes(x = weight, y = lp100km)) +
  geom_point() +
  ylab("Litres per 100 kilometres") +
  ggtitle("Gas usage")
obj
```

However, this design has an obvious drawback: confusion of the output data structure. Since the transformation is accomplished at the printing time, object `obj` is still a `ggplot` data structure. To create a `loon` "handle", we have to use `l_getFromPath()`
```{r, l_getFromPath, message = FALSE, eval = FALSE}
if(utils::packageVersion("loon") >= "1.2.4") {
  # **THIS IS IMPORTANT**
  # The path name can be obtained at the top left tk window
  # Suppose the label is "loon.ggplot --path: .l13.ggplot"
  # The path would be the char right after "path: " which is ".l13.ggplot"
  loonWidget <- l_getFromPath(".l13.ggplot")
  class(loonWidget)
  # [1] "l_plot" "loon"
}
```

### Just use loon for built-in interactive plots

Of course, for plots already existing in `loon`,  `ggplot()` and hence `gg_pipe()` could be avoided entirely:
```{r loon_only_pipe, message = FALSE, warning = FALSE, eval = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
mtcars %>%
  rename(transmission = am, weight = wt) %>%
  mutate(lp100km = (100 * 3.785411784) / (1.609344 * mpg)) %>%
  select(weight, lp100km) %>%
  # and pass the built plot on
  l_plot(title = "Gas Usage", 
         showGuides = TRUE, showScales = TRUE,
         ylabel = "Litres per 100 kilometres", 
         linkingGroup = "Motor Trend 1974") %>%
  plot()   # get a static version via grid
```

```{r loon_only_pipe_graph, echo = FALSE, message = FALSE,  warning = FALSE, fig.width = 5, fig.height = 4, fig.align = "center", out.width = "70%"}
#include_graphics(file.path(imageDirectory, "gas_usage.png"))
```
